/*
Script: root_task.sql
Description: DDL statements to create the root task.
Team: Data Engineering
Date: 2026-01-10
Parameters: tsch - Schema identifier (e.g., DE) | csch - common Schema identifier (e.g., COMMON)

Cron Schedule:
# __________ minute (0-59)
# | ________ hour (0-23)
# | | ______ day of month (1-31, or L)
# | | | ____ month (1-12, JAN-DEC)
# | | | | __ day of week (0-6, SUN-SAT, or L)
# | | | | |
# | | | | |
  * * * * *
*/
CREATE TASK IF NOT EXISTS HACKATHON_DB.HACKATHON_{{tsch}}_SCH.ROOT_TASK
SCHEDULE = 'USING CRON 15 0,4,8,12,16,20 * * * America/Chicago'
TIMESTAMP_INPUT_FORMAT = 'YYYY-MM-DD HH24'
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
SERVERLESS_TASK_MIN_STATEMENT_SIZE = 'XSMALL'
SERVERLESS_TASK_MAX_STATEMENT_SIZE = 'SMALL'
ALLOW_OVERLAPPING_EXECUTION = FALSE
LOG_LEVEL = INFO
COMMENT = 'Created by Prakash Loganathan'
AS
EXECUTE IMMEDIATE $$
    BEGIN
    ---SET RETURN VALUE
    CALL SYSTEM$SET_RETURN_VALUE('SUCCEEDED');
    END;
$$
;

CREATE TASK IF NOT EXISTS HACKATHON_DB.HACKATHON_{{tsch}}_SCH.STAGE_TABLE_TASK
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
SERVERLESS_TASK_MIN_STATEMENT_SIZE = 'XSMALL'
SERVERLESS_TASK_MAX_STATEMENT_SIZE = 'SMALL'
ALLOW_OVERLAPPING_EXECUTION = FALSE
LOG_LEVEL = INFO
AFTER HACKATHON_DB.HACKATHON_{{tsch}}_SCH.ROOT_TASK
WHEN SYSTEM$GET_PREDECESSOR_RETURN_VALUE('ROOT_TASK') = 'SUCCEEDED'
AS
EXECUTE IMMEDIATE $$
    BEGIN
    ---RUN THE PROCEDURE
    CALL HACKATHON_DB.HACKATHON_{{tsch}}_SCH.STAGE_TABLE_SPROC('HACKATHON_DB', 'HACKATHON_{{tsch}}_SCH', 'HACKATHON_{{csch}}_SCH');
    
    ---SET RETURN VALUE
    CALL SYSTEM$SET_RETURN_VALUE('SUCCEEDED');
    END;
$$
;

CREATE TASK IF NOT EXISTS HACKATHON_DB.HACKATHON_{{tsch}}_SCH.TARGET_TABLE_TASK
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
SERVERLESS_TASK_MIN_STATEMENT_SIZE = 'XSMALL'
SERVERLESS_TASK_MAX_STATEMENT_SIZE = 'SMALL'
ALLOW_OVERLAPPING_EXECUTION = FALSE
LOG_LEVEL = INFO
AFTER HACKATHON_DB.HACKATHON_{{tsch}}_SCH.STAGE_TABLE_TASK
WHEN SYSTEM$GET_PREDECESSOR_RETURN_VALUE('STAGE_TABLE_TASK') = 'SUCCEEDED'
AS
EXECUTE IMMEDIATE $$
    BEGIN
    ---RUN THE PROCEDURE
    CALL HACKATHON_DB.HACKATHON_{{tsch}}_SCH.TARGET_TABLE_SPROC('HACKATHON_DB', 'HACKATHON_{{tsch}}_SCH', 'HACKATHON_{{tsch}}_SCH');
    
    ---SET RETURN VALUE
    CALL SYSTEM$SET_RETURN_VALUE('SUCCEEDED');
    END;
$$
;

--Finalizer Task
CREATE TASK IF NOT EXISTS HACKATHON_DB.HACKATHON_{{tsch}}_SCH.FINALIZE_TASK
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
SERVERLESS_TASK_MIN_STATEMENT_SIZE = 'XSMALL'
SERVERLESS_TASK_MAX_STATEMENT_SIZE = 'SMALL'
ALLOW_OVERLAPPING_EXECUTION = FALSE
LOG_LEVEL = INFO
FINALIZE = HACKATHON_DB.HACKATHON_{{tsch}}_SCH.ROOT_TASK
AS
EXECUTE IMMEDIATE $$
  DECLARE
    my_root_task_id STRING;
    my_start_time TIMESTAMP_LTZ;
    summary_json STRING;
    summary_html STRING;
    
  BEGIN
    --- Get root task ID
    my_root_task_id := (SELECT SYSTEM$TASK_RUNTIME_INFO('CURRENT_ROOT_TASK_UUID'));
    
    --- Get root task scheduled time
    my_start_time := (SELECT SYSTEM$TASK_RUNTIME_INFO('CURRENT_TASK_GRAPH_ORIGINAL_SCHEDULED_TIMESTAMP')::timestamp_ltz);
    
    --- Combine all task run info into one JSON string
    summary_json := (SELECT HACKATHON_DB.HACKATHON_{{csch}}_SCH.GET_GRAPH_RUN_SUMMARY(:my_root_task_id, :my_start_time, '_TASK'));
    
    --- Convert JSON into HTML table
    summary_html := (SELECT HACKATHON_DB.HACKATHON_{{csch}}_SCH.HTML_FROM_JSON_TASK_RUNS(PARSE_JSON(:summary_json)));

    --- Send HTML to email
    CALL SYSTEM$SEND_EMAIL(
        'ALERTS_EMAIL_INT',
        'prakloga1205@gmail.com',
        'SNOWFLAKE TASKs Run Summary',
        :summary_html,
        'text/html');
        
    --- Set return value for finalizer
    CALL SYSTEM$SET_RETURN_VALUE('âœ… Graph run summary sent.');
  END;
$$
;